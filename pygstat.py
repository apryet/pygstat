from subprocess import call
import numpy as np
import random
from matplotlib import pyplot as plt
import matplotlib.cm as cm
from scipy.interpolate import griddata
import os


class GstatModel():
    # TODO : implement experimental variogram modeling
    # TODO : validate for various types of variogram models

    def __init__(self,
                 case='case',
                 dim=2,
                 vario=None,
                 data=None,
                 loc=None,
                 nmin=None,
                 nmax=None,
                 radius=None,
                 sk_mean=0,
                 nsim=None,
                 log_transform=False,
                 block_size=None,
                 var_name='var',
                 length_unit='m',
                 gstat_prg_cmd=os.path.expanduser('~') +
                 '/Programmes/python/pygstat/'):

        # case [char] : name of current case
        # dim [int] : dimensions of the problem (2 for 2D, 3 for 3D)
        # vario [dict] : variogram model {'nugget':0.1, 'model':'Sph', 'c':1.0, 'range':100, 'angle':0, 'anis': 1}
        #                where c is the covariance scaling factor (partial sill, without nugget)
        # data [numpy array] : Nx3 (if dim=2) or 4xN (if dim=3) array containing coordinates and
        #                variable values.
        # loc [numpy array] : Locations where values will be interpolated.
        #                     The array must contain x in the 1st column and y in the 2nd column
        # nmin : minimum number of observations in a local neighborhood selection.
        # nmax : maximum number of observations in a local neighborhood selection.
        # radius :   maximum distance of observations in the local neighborhood selection.
        # sk_mean [float] : mean of the simulated variable for simulations
        # nsim [int] : number of simulations to perform
        # log_transform [Bool] : If true, the variable is log-transformed.
        # block_size [float] : size of rectangle for block kriging
        # var_name [char] : name of variable to predict
        # length_unit [char] : unit of the variable, for printing purposes only

        self.case = case
        self.dim = dim
        self.vario = vario
        self.data = data

        # add ids to loc array
        ids = np.arange(loc.shape[0])
        ids.shape = (loc.shape[0], 1)
        self.loc = np.hstack((loc, ids))

        self.nmin = nmin
        self.nmax = nmax
        self.radius = radius

        self.sk_mean = sk_mean
        self.nsim = nsim
        self.log_transform = log_transform
        self.block_size = block_size

        self.var_name = var_name
        self.length_unit = length_unit

        self.loc_file = case + '.loc'
        self.data_file = case + '.dat'
        self.cmd_file = case + '.cmd'
        self.pred_file = case + '.pred'

        self.gstat_prg_cmd = gstat_prg_cmd

        self.options = {}

    # -- define comment line in command file
    def def_comment(self):
        return ('# Gstat command file generated by pygstat \n' + '# Case ' +
                self.case + '\n')

    # -- define data line in command file
    def def_data(self):
        if self.data is None:
            data_string = 'data(' + self.case + '): dummy, sk_mean =' + str(
                self.sk_mean)
        else:
            data_string = 'data(' + self.case + '): ' + '\'' + self.data_file + '\', '

            if self.dim == 2:
                data_string += 'x=1, y=2, v=3,'
            if self.dim == 3:
                data_string += 'x=1, y=2, z=3, v=4,'

            if self.log_transform == True:
                data_string += ' log,'

            if self.nmin is not None:
                data_string += 'min=' + str(self.nmin) + ','

            if self.nmax is not None:
                data_string += 'max=' + str(self.nmax) + ','

            if self.radius is not None:
                data_string += 'radius=' + str(self.radius)

        data_string += ';\n'
        return (data_string)

    # -- define variogram line in command file
    def def_vario(self):
        vario_string = 'variogram(' + self.case + '): '

        vario_string += str(self.vario['nugget']) + ' Nug() + ' + \
              str(self.vario['c']) + ' ' + self.vario['model'] + '(' + str(self.vario['range']) + ','

        vario_string += str(self.vario['angle']) + ',' + str(
            self.vario['anis'])
        vario_string += ');\n'

        return (vario_string)

    # -- define location line in command file
    def def_loc(self):

        loc_string = 'data(): ' + '\'' + self.loc_file + '\', '

        if self.dim == 2:
            loc_string += 'x=1, y=2, v=3,'
        if self.dim == 3:
            loc_string += 'x=1, y=2, z=3, v=4,'

        loc_string += ';\n'

        return (loc_string)

    # -- define block line in command file
    def def_block(self):

        if self.block_size is not None:
            block_string = 'blocksize: dx=' + self.block_size + ', dy=' + self.block_size
            block_string += ';\n'
            return (block_string)
        else:
            return ('')

    # -- define option lines in command file
    def def_method(self):
        method_string = ''
        if self.nsim is not None:
            method_string = 'method: gs;\n'  # Gaussian simulation

        if self.vario is None:
            method_string = 'method: semivariogram;\n'  # Gaussian simulation

        return (method_string)

    # -- define option lines in command file
    def def_options(self):
        options_string = ''
        self.options['output'] = '\'' + self.pred_file + '\''

        if self.nsim is not None:
            self.options['nsim'] = self.nsim

        for option_name in list(self.options.keys()):
            options_string += 'set ' + option_name + ' = ' + str(
                self.options[option_name]) + ';\n'

        return (options_string)

    # -- write cmd file
    def write_cmd(self):
        with open(self.cmd_file, 'w') as f:
            f.write(self.def_comment())
            f.write(self.def_data())
            f.write(self.def_vario())
            f.write(self.def_loc())
            f.write(self.def_block())
            f.write(self.def_method())
            f.write(self.def_options())

    # -- write table compatible with gstat
    def write_table(self, table, output_file):
        with open(output_file, 'w') as f:
            # write header
            f.write('Gstat table generated by PyGstat\n')
            f.write(str(table.shape[1]) + '\n')
            f.write('xcoord, ' + self.length_unit + '\n')
            f.write('ycoord, ' + self.length_unit + '\n')
            if self.dim == 3:
                f.write('zcoord, ' + self.length_unit + '\n')

            # write data column names
            for i in range(self.dim, table.shape[1]):
                f.write('v' + str(i - 1) + '\n')

            # write table
            np.savetxt(f, table)

    # -- read gstat output table
    def read_table(self, input_file):
        with open(input_file, 'r') as f:
            comment = f.readline()
            ncol = int(f.readline())
            col_names = []
            for i in range(ncol):
                # get col names and remove \n
                col_names.append(f.readline()[:-1])

            table = np.loadtxt(f)

        return (table)

    # -- write I/O files and run gstat
    def run(self):
        # write command file
        self.write_cmd()

        # if data is provided, write data file
        if self.data is not None:
            self.write_table(self.data, self.data_file)

        self.write_table(self.data, self.data_file)

        # write location file
        self.write_table(self.loc, self.loc_file)

        # call gstat
        call([self.gstat_prg_cmd, self.cmd_file])

    # -- retrieve results from pred file
    def read_pred(self):
        return (self.read_table(self.pred_file))

    # -- plot predictions map
    def plot_pred(self, N=100j):
        pred = self.read_pred()
        xs0 = pred[:, 0]
        ys0 = pred[:, 1]
        zs0 = pred[:, 3]

        extent = (np.min(pred[:, 0]), np.max(pred[:, 0]), np.min(pred[:, 1]),
                  np.max(pred[:, 1]))

        xs, ys = np.mgrid[extent[0]:extent[1]:N, extent[2]:extent[3]:N]

        #resampled = griddata(xs0, ys0, zs0, xs, ys)
        resampled = griddata(np.array(list(zip(xs0, ys0))), zs0,
                             np.array(list(zip(xs.ravel(), ys.ravel()))))
        resampled = np.reshape(resampled, xs.shape)

        plt.ion()
        plt.imshow(resampled.T, extent=extent, cmap=cm.Greys_r)
        plt.colorbar()
        plt.show()

    # -- generate a set of points within the domain covered by loc
    def gen_ptset(self, n):

        coord = []

        # coordinates  min-max
        for i in range(self.dim):
            coord.append([])
            coord_min = np.min(self.loc[:, i])
            coord_max = np.max(self.loc[:, i])
            for j in range(n):
                coord[i].append(random.uniform(coord_min, coord_max))

        return (np.transpose(np.array(coord)))
